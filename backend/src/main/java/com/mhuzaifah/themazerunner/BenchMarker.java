package com.mhuzaifah.themazerunner;

import java.util.Objects;

public class BenchMarker {

    private long start;
    private long end;
    private boolean currentlyTiming;
    private boolean haveStoredTiming;
    private String mapLoadingTime;
    private String rightHandTime;
    private String baselineTime;

    BenchMarker() {
        this.start = 0;
        this.end = 0;
        this.currentlyTiming = false;
        this.haveStoredTiming = false;
        this.mapLoadingTime = "";
        this.rightHandTime = "";
        this.baselineTime = "";
    }

    /**
     * Starts the timer.
     */
    public void startTimer() {
        if(!currentlyTiming) {
            start = System.nanoTime();
            currentlyTiming = true;
        }
        else {
            throw new IllegalStateException("Cannot start timer since it is already currently active.");
        }
    }

    /**
     * Ends the timer.
     */
    public void endTimer() {
        if(currentlyTiming) {
            end = System.nanoTime();
            currentlyTiming = false;
            haveStoredTiming = true;
        }
        else {
            throw new IllegalStateException("Cannot end timer since it has not been activated yet.");
        }

    }

    /**
     * Sets the time specified task took.
     *
     * @param task Task being timed
     */
    public void setTiming(String task) {
        if(haveStoredTiming) {
            double elapsedTime = (end - start) / 1000000.0;
            String formattedTime = String.format("%.2f", elapsedTime);
            switch (task.toLowerCase()) {
                case "map" -> {
                    this.mapLoadingTime = formattedTime;
                }
                case "righthand" -> {
                    this.rightHandTime = formattedTime;
                }
                case "baseline" -> {
                    this.baselineTime = formattedTime;
                }
                default -> {
                    throw new IllegalStateException("Timing for '" + task + "' not supported.");
                }
            }

            start = 0;
            end = 0;
            haveStoredTiming = false;
        }
        else {
            throw new IllegalStateException("Cannot set timing since no start or end timings have not been recorded.");
        }
    }

    /**
     * Get the map loading time.
     *
     * @return Formatted map loading time
     */
    public String getMapLoadingTime() {
        return this.mapLoadingTime;
    }

    /**
     * Get the right hand algorithm time.
     *
     * @return Formatted right hand algorithm time
     */
    public String getRightHandTime() {
        return this.rightHandTime;
    }

    /**
     * Get the baseline algorithm time.
     *
     * @return Formatted baseline algorithm time
     */
    public String getBaselineTime() {
        return this.baselineTime;
    }

    /**
     * Calculate the speedup.
     *
     * @param rightHandPath Path generated by right hand algorithm
     * @param baselinePath Path generated by baseline algorithm
     * @return Speedup between the algorithms
     */
    public String calculateSpeedUp(Path rightHandPath, Path baselinePath) {

        if(!Objects.equals(rightHandTime, "") && !Objects.equals(baselineTime, "")) {
            double speedup = (double) rightHandPath.getPathSteps().size() / baselinePath.getPathSteps().size();
            return String.format("%.2f", speedup);
        }
        else {
            throw new IllegalStateException("Cannot calculate speedup since either RightHand time or Baseline time have not been calculated");
        }

    }

}
